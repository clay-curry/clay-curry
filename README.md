## me

im an average computer programmer from the average place of [Oklahoma City](https://www.visitokc.com) with an unusual connection to tooling, history of technology, applied statistics, and human computer interaction. usually some combination of these will decide how I use my time and energy. whenever my terminal is closed, people around me generally find me funny and easy to deeply connect with. otherwise, i'm locked in. 

are you building something cool (measured in stars, users, engagement) together? looking for a teammate? [email me](mailto:me@claycurry.com) (please)!

i value personal connections, learning opportunities, and any recognized [currency](https://en.wikipedia.org/wiki/List_of_circulating_currencies) (any listed) in that order.

<!--

- Interests:
  - modular programming (CSM, ESM),
  - functional programming (redux, react compiler),
  - monorepos (nx, Turborepo)
  - static module bundlers (Rspack, webpack, Turbopack, Rollup, Vite),
  - linting observability (programs, hot modules)
 


> To me, error analysis is the sweet spot for improvement.

> In my opinion, no single design is apt to be optimal for everyone.

> Standards define what great looks like, setting consistent benchmarks for businesses and consumers alike — ensuring reliability, building trust, and simplifying choices.

Making lives easier, safer and better.

Until i find a better resource, heres a pretty 
Software tools come in many forms:
Binary compatibility analysis tools
Bug databases: Comparison of issue tracking systems – Including bug tracking systems
Build tools: Build automation, List of build automation software
Call graph
Code coverage: Code coverage#Software code coverage tools.
Code review: List of tools for code review
Code sharing sites: Freshmeat, Krugle, SourceForge, GitHub. See also Code search engines.
Compilation and linking tools: GNU toolchain, gcc, Microsoft Visual Studio, CodeWarrior, Xcode, ICC
Debuggers: Debugger#List of debuggers. See also Debugging.
Disassemblers: Generally reverse-engineering tools.
Documentation generators: Comparison of documentation generators, help2man, Plain Old Documentation, asciidoc
Formal methods: Mathematical techniques for specification, development and verification
GUI interface generators
Library interface generators: SWIG
Integration Tools
Memory debuggers are frequently used in programming languages (such as C and C++) that allow manual memory management and thus the possibility of memory leaks and other problems. They are also useful to optimize efficiency of memory usage. Examples: dmalloc, Electric Fence, Insure++, Valgrind
Parser generators: Parsing#Parser development software
Performance analysis or profiling: List of performance analysis tools
Revision control: List of revision control software, Comparison of revision control software
Scripting languages: PHP, AWK, Perl, Python, REXX, Ruby, Shell, Tcl
Search: grep, find
Source code Clones/Duplications Finding: Duplicate code#Tools
Source code editor
Text editors: List of text editors, Comparison of text editors
Source code formatting: indent, pretty-printers, beautifiers, minifiers
Source code generation tools: Automatic programming#Implementations
Static code analysis: lint, List of tools for static code analysis
Unit testing: List of unit testing frameworks
IDEs


## Art

<br>

Call-stack (screaming for memoization).

<img src="https://github.com/clay-curry/clay-curry/blob/main/procedure-graph.png" alt="Call-stack shape for a computation based on tree-recursion" width="500" />

(image from [Structure and Interpretation of Computer Programs](https://web.mit.edu/6.001/6.037/sicp.pdf))

<br><br>

Reducing visual clutter of adjacency graph (i.e. control flow) via hierarchical edge bundling. (image from [Hierarchical Edge Bundling](https://www.data-to-viz.com/graph/edge_bundling.html))

<br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/edge-bundling.png" alt="Reducing visual clutter of adjacency graph via hierarchical edge bundling." width="500" />

(can we rearrange chunks to maximize cache hits between iterations?)


<br><br>


Contrast render-trees (how engines "think") and module dependency trees (how developers "think")


<br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/render-tree.png" alt="Render Tree" width="500" />
<img src="https://github.com/clay-curry/clay-curry/blob/main/dependency-tree.png" alt="Dependency Tree" width="500" />

(image from [Understanding Your UI as a Tree](https://react.dev/learn/understanding-your-ui-as-a-tree))

<br><br>

Neighborhoods of dependencies.

<br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/Tree_graph.png" alt="tree" />


-->
