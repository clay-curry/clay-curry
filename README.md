## 


I tend to get bored and try new things. 

<!--
Until i find a better resource, heres a pretty 
Software tools come in many forms:
Binary compatibility analysis tools
Bug databases: Comparison of issue tracking systems â€“ Including bug tracking systems
Build tools: Build automation, List of build automation software
Call graph
Code coverage: Code coverage#Software code coverage tools.
Code review: List of tools for code review
Code sharing sites: Freshmeat, Krugle, SourceForge, GitHub. See also Code search engines.
Compilation and linking tools: GNU toolchain, gcc, Microsoft Visual Studio, CodeWarrior, Xcode, ICC
Debuggers: Debugger#List of debuggers. See also Debugging.
Disassemblers: Generally reverse-engineering tools.
Documentation generators: Comparison of documentation generators, help2man, Plain Old Documentation, asciidoc
Formal methods: Mathematical techniques for specification, development and verification
GUI interface generators
Library interface generators: SWIG
Integration Tools
Memory debuggers are frequently used in programming languages (such as C and C++) that allow manual memory management and thus the possibility of memory leaks and other problems. They are also useful to optimize efficiency of memory usage. Examples: dmalloc, Electric Fence, Insure++, Valgrind
Parser generators: Parsing#Parser development software
Performance analysis or profiling: List of performance analysis tools
Revision control: List of revision control software, Comparison of revision control software
Scripting languages: PHP, AWK, Perl, Python, REXX, Ruby, Shell, Tcl
Search: grep, find
Source code Clones/Duplications Finding: Duplicate code#Tools
Source code editor
Text editors: List of text editors, Comparison of text editors
Source code formatting: indent, pretty-printers, beautifiers, minifiers
Source code generation tools: Automatic programming#Implementations
Static code analysis: lint, List of tools for static code analysis
Unit testing: List of unit testing frameworks
IDEs
-->

## About Me

- Homepage: [claycurry.com](https://claycurry.com)

- B.S., Computer Science, University of Oklahoma

- Formerly (2 years) Linux System Administrator @ University of Oklahoma:
  - ðŸ”­ [Dept of Physics & Astronomy](https://ou.edu/cas/physics-astronomy) (10 months)
  - ðŸ‘¾ [School of Computer Science](https://cs.ou.edu) (13 months)

- Currently Building:
 
- Selected Projects ([pinned below](#below))

## Currently on my Mind

Call-stack based on tree-recursion (screaming for memoization). (image from [Structure and Interpretation of Computer Programs](https://web.mit.edu/6.001/6.037/sicp.pdf))

<br><br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/procedure-graph.png" alt="Call-stack shape for a computation based on tree-recursion" width="500" />

<br><br>

Reducing visual clutter of adjacency graph via hierarchical edge bundling. (image from [Hierarchical Edge Bundling](https://www.data-to-viz.com/graph/edge_bundling.html))

<br><br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/edge-bundling.png" alt="Reducing visual clutter of adjacency graph via hierarchical edge bundling." width="500" />
(could this be used to truly optimal bundlers?)

<br><br>


Contrast between the graphical structure of a render-tree and module dependency tree in React. (image from [Understanding Your UI as a Tree](https://react.dev/learn/understanding-your-ui-as-a-tree))

<br><br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/render-tree.png" alt="Render Tree" width="500" />
<img src="https://github.com/clay-curry/clay-curry/blob/main/dependency-tree.png" alt="Dependency Tree" width="500" />

#### below
