<!-- 

## Hi, I'm Clay ðŸ‘‹

![Claude](https://img.shields.io/badge/-Claude-cc785c?style=flat&logo=anthropic&logoColor=white) 

<a href="https://x.com/yourusername">
  <img src="https://about.x.com/content/dam/about-twitter/x/large-x-logo.png.twimg.1920.png" height="10" width="10" alt="X Logo">
</a>


[LinkedIn](https://linkedin.com/in/clay-curry)

ðŸ¤– Software Engineer.

**San Francisco, CA** Â· [claycurry.com](https://claycurry.com)Â· 
 Â· 

===

I am a product-driven  


un


involves turning a business vision

aiming to surround myself.




to find new (and old) ways to be to my peeros, while bringing a sense of humor 

My favorite role

I enjoy creating turning ,



is  into a functional and user-friendly but at the same time attractive

I see my role =a




I've worked with enough web technologies to see thoguh


including React, Next.js, Node.js, and modern cloud platforms.





website or application so that it . My aim is to bring across your message and identity in the most creative way. 
-->
<!--

- Interests:
  - modular programming (CSM, ESM),
  - functional programming (redux, react compiler),
  - monorepos (nx, Turborepo)
  - static module bundlers (Rspack, webpack, Turbopack, Rollup, Vite),
  - linting observability (programs, hot modules)
 



> To me, error analysis is the sweet spot for improvement.

> In my opinion, no single design is apt to be optimal for everyone.

> Standards define what great looks like, setting consistent benchmarks for businesses and consumers alike â€” ensuring reliability, building trust, and simplifying choices.

Making lives easier, safer and better.

Until i find a better resource, heres a pretty 
Software tools come in many forms:
Binary compatibility analysis tools
Bug databases: Comparison of issue tracking systems â€“ Including bug tracking systems
Build tools: Build automation, List of build automation software
Call graph
Code coverage: Code coverage#Software code coverage tools.
Code review: List of tools for code review
Code sharing sites: Freshmeat, Krugle, SourceForge, GitHub. See also Code search engines.
Compilation and linking tools: GNU toolchain, gcc, Microsoft Visual Studio, CodeWarrior, Xcode, ICC
Debuggers: Debugger#List of debuggers. See also Debugging.
Disassemblers: Generally reverse-engineering tools.
Documentation generators: Comparison of documentation generators, help2man, Plain Old Documentation, asciidoc
Formal methods: Mathematical techniques for specification, development and verification
GUI interface generators
Library interface generators: SWIG
Integration Tools
Memory debuggers are frequently used in programming languages (such as C and C++) that allow manual memory management and thus the possibility of memory leaks and other problems. They are also useful to optimize efficiency of memory usage. Examples: dmalloc, Electric Fence, Insure++, Valgrind
Parser generators: Parsing#Parser development software
Performance analysis or profiling: List of performance analysis tools
Revision control: List of revision control software, Comparison of revision control software
Scripting languages: PHP, AWK, Perl, Python, REXX, Ruby, Shell, Tcl
Search: grep, find
Source code Clones/Duplications Finding: Duplicate code#Tools
Source code editor
Text editors: List of text editors, Comparison of text editors
Source code formatting: indent, pretty-printers, beautifiers, minifiers
Source code generation tools: Automatic programming#Implementations
Static code analysis: lint, List of tools for static code analysis
Unit testing: List of unit testing frameworks
IDEs


## Art

<br>

Call-stack (screaming for memoization).

<img src="https://github.com/clay-curry/clay-curry/blob/main/procedure-graph.png" alt="Call-stack shape for a computation based on tree-recursion" width="500" />

(image from [Structure and Interpretation of Computer Programs](https://web.mit.edu/6.001/6.037/sicp.pdf))

<br><br>

Reducing visual clutter of adjacency graph (i.e. control flow) via hierarchical edge bundling. (image from [Hierarchical Edge Bundling](https://www.data-to-viz.com/graph/edge_bundling.html))

<br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/edge-bundling.png" alt="Reducing visual clutter of adjacency graph via hierarchical edge bundling." width="500" />

(can we rearrange chunks to maximize cache hits between iterations?)


<br><br>


Contrast render-trees (how engines "think") and module dependency trees (how developers "think")


<br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/render-tree.png" alt="Render Tree" width="500" />
<img src="https://github.com/clay-curry/clay-curry/blob/main/dependency-tree.png" alt="Dependency Tree" width="500" />

(image from [Understanding Your UI as a Tree](https://react.dev/learn/understanding-your-ui-as-a-tree))

<br><br>

Neighborhoods of dependencies.

<br>

<img src="https://github.com/clay-curry/clay-curry/blob/main/Tree_graph.png" alt="tree" />


-->
